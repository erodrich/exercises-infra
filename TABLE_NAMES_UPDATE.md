# Database Table Names Update

**Date**: 2024-12-19  
**Version**: 1.1.0 (revised)  
**Impact**: Schema alignment with backend entities

## Summary

Updated SQL scripts to match the actual table names used by the backend JPA entities. Removed `_entity` suffix from table names and added proper `muscle_groups` table structure.

## Changes Made

### Table Name Changes

| Old Name (Incorrect) | New Name (Correct) | Notes |
|---------------------|-------------------|-------|
| `exercise_entity` | `exercises` | Main exercises table |
| `exercise_log_entity` | `exercise_logs` | Workout logs table |
| `exercise_set_entity` | `exercise_sets` | Sets table |
| N/A | `muscle_groups` | NEW - Muscle group categories |
| `exercise_log_sets` | `exercise_log_sets` | No change (join table) |
| `users` | `users` | No change |

### Sequence Name Changes

| Old Name | New Name |
|----------|----------|
| `exercise_entity_seq` | `exercises_seq` |
| `exercise_log_entity_seq` | `exercise_logs_seq` |
| N/A | `muscle_groups_seq` (NEW) |
| `users_seq` | `users_seq` (no change) |

### Schema Structure Changes

#### Old Schema (Incorrect)
```sql
-- Used enum for muscle group (0-5)
CREATE TABLE exercise_entity (
    id BIGINT NOT NULL PRIMARY KEY,
    name VARCHAR(255),
    muscle_group SMALLINT CHECK (muscle_group BETWEEN 0 AND 5)
);
```

#### New Schema (Correct)
```sql
-- Muscle groups as separate table
CREATE TABLE muscle_groups (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    description VARCHAR(255)
);

-- Exercises reference muscle_groups
CREATE TABLE exercises (
    id BIGINT NOT NULL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    muscle_group_id BIGINT NOT NULL,
    CONSTRAINT fk_exercises_muscle_group 
        FOREIGN KEY (muscle_group_id) REFERENCES muscle_groups(id)
);
```

## Backend Entity Mappings

Verified against backend JPA entities:

```java
@Entity
@Table(name = "users")
public class UserEntity { ... }

@Entity
@Table(name = "muscle_groups")
public class MuscleGroupEntity { ... }

@Entity
@Table(name = "exercises")
public class ExerciseEntity { 
    @ManyToOne
    @JoinColumn(name = "muscle_group_id")
    private MuscleGroupEntity muscleGroup;
    ...
}

@Entity
@Table(name = "exercise_logs")
public class ExerciseLogEntity { ... }

@Entity
@Table(name = "exercise_sets")
public class ExerciseSetEntity { ... }
```

## Files Updated

### 1. `database/01-schema.sql`
- Removed `_entity` suffix from all table names
- Added `muscle_groups` table with proper structure
- Updated all foreign key references
- Updated sequence names
- Updated indexes to match new table names
- Updated all comments

**Key Changes:**
```sql
-- OLD
DROP TABLE IF EXISTS exercise_entity CASCADE;
CREATE SEQUENCE exercise_entity_seq START WITH 1 INCREMENT BY 50;
CREATE TABLE exercise_entity (id BIGINT, name VARCHAR, muscle_group SMALLINT);

-- NEW
DROP TABLE IF EXISTS exercises CASCADE;
DROP TABLE IF EXISTS muscle_groups CASCADE;
CREATE SEQUENCE exercises_seq START WITH 1 INCREMENT BY 50;
CREATE SEQUENCE muscle_groups_seq START WITH 1 INCREMENT BY 50;
CREATE TABLE muscle_groups (id BIGINT, name VARCHAR(50), description VARCHAR(255));
CREATE TABLE exercises (id BIGINT, name VARCHAR(255), muscle_group_id BIGINT);
```

### 2. `database/02-seed-data.sql`
- Updated to insert muscle groups first
- Changed all `exercise_entity` to `exercises`
- Changed muscle group enum values (0-5) to foreign key references (1-6)
- Added muscle group descriptions
- Updated sequence update statements

**Key Changes:**
```sql
-- OLD
INSERT INTO exercise_entity (id, name, muscle_group) VALUES (1, 'Bench Press', 0);
SELECT setval('exercise_entity_seq', 50);

-- NEW
INSERT INTO muscle_groups (id, name, description) VALUES (1, 'Chest', 'Pectoral muscles');
INSERT INTO exercises (id, name, muscle_group_id) VALUES (1, 'Bench Press', 1);
SELECT setval('muscle_groups_seq', 10);
SELECT setval('exercises_seq', 50);
```

### 3. `database/README.md`
- Updated table listings
- Updated sequence listings
- Added muscle groups descriptions
- Updated database schema diagram
- Updated verification queries
- Updated expected output counts

## Database Schema Diagram

### New Structure
```
┌──────────────────┐
│  muscle_groups   │ (NEW TABLE)
│──────────────────│
│ id (PK)          │───┐
│ name (UNIQUE)    │   │
│ description      │   │
└──────────────────┘   │
                       │ (FK)
                       ▼
                  ┌──────────┐
                  │exercises │ (RENAMED)
                  │──────────│
                  │ id       │
                  │ name     │
                  │ muscle_  │
                  │ group_id │──┐
                  └──────────┘  │
                                │
                                ▼
                  ┌──────────────────┐
                  │  exercise_logs   │ (RENAMED)
                  └──────────────────┘
                            │
                            ▼
                  ┌──────────────────┐
                  │  exercise_sets   │ (RENAMED)
                  └──────────────────┘
```

## Migration Impact

### Fresh Installations
✅ **No action needed** - New schema will be created automatically

### Existing Deployments
⚠️ **Migration Required** - Database must be updated

#### Option 1: Fresh Start (Recommended for Dev)
```bash
# Stop services
docker-compose down

# Remove database volume (WARNING: DELETES DATA)
docker volume rm dev_postgres_data

# Start with new schema
docker-compose up -d
```

#### Option 2: Manual Migration (For Production with Data)
```bash
# Backup first!
docker exec exercises-postgres-prod pg_dump -U postgres exercises_prod > backup.sql

# Then apply migration (see Migration SQL below)
```

## Migration SQL

For existing databases with data, use these migration scripts:

### Step 1: Create muscle_groups table
```sql
-- Create muscle groups table
CREATE TABLE IF NOT EXISTS muscle_groups (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    description VARCHAR(255)
);

CREATE SEQUENCE IF NOT EXISTS muscle_groups_seq START WITH 1 INCREMENT BY 50;
CREATE INDEX idx_muscle_groups_name ON muscle_groups(name);
```

### Step 2: Populate muscle groups
```sql
INSERT INTO muscle_groups (id, name, description) VALUES 
    (1, 'Chest', 'Pectoral muscles'),
    (2, 'Back', 'Latissimus dorsi, trapezius, rhomboids'),
    (3, 'Shoulders', 'Deltoid muscles'),
    (4, 'Legs', 'Quadriceps, hamstrings, glutes, calves'),
    (5, 'Biceps', 'Biceps brachii'),
    (6, 'Triceps', 'Triceps brachii')
ON CONFLICT (id) DO NOTHING;

SELECT setval('muscle_groups_seq', 10);
```

### Step 3: Rename tables (if old names exist)
```sql
-- Check if old tables exist
DO $$ 
BEGIN
    -- Rename exercise_entity to exercises
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'exercise_entity') THEN
        ALTER TABLE exercise_entity RENAME TO exercises;
    END IF;
    
    -- Rename exercise_log_entity to exercise_logs
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'exercise_log_entity') THEN
        ALTER TABLE exercise_log_entity RENAME TO exercise_logs;
    END IF;
    
    -- Rename exercise_set_entity to exercise_sets
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'exercise_set_entity') THEN
        ALTER TABLE exercise_set_entity RENAME TO exercise_sets;
    END IF;
END $$;
```

### Step 4: Update exercises table structure
```sql
-- Add muscle_group_id column if it doesn't exist
ALTER TABLE exercises 
ADD COLUMN IF NOT EXISTS muscle_group_id BIGINT;

-- Migrate data from old muscle_group enum to new muscle_group_id
-- Assuming old enum values were 0-5, new IDs are 1-6
UPDATE exercises 
SET muscle_group_id = muscle_group + 1 
WHERE muscle_group_id IS NULL AND muscle_group IS NOT NULL;

-- Add foreign key constraint
ALTER TABLE exercises
ADD CONSTRAINT IF NOT EXISTS fk_exercises_muscle_group 
    FOREIGN KEY (muscle_group_id) REFERENCES muscle_groups(id);

-- Drop old muscle_group column (after verifying data)
-- ALTER TABLE exercises DROP COLUMN IF EXISTS muscle_group;

-- Make muscle_group_id NOT NULL
ALTER TABLE exercises 
ALTER COLUMN muscle_group_id SET NOT NULL;
```

### Step 5: Rename sequences
```sql
-- Rename sequences if they exist
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM pg_sequences WHERE sequencename = 'exercise_entity_seq') THEN
        ALTER SEQUENCE exercise_entity_seq RENAME TO exercises_seq;
    END IF;
    
    IF EXISTS (SELECT 1 FROM pg_sequences WHERE sequencename = 'exercise_log_entity_seq') THEN
        ALTER SEQUENCE exercise_log_entity_seq RENAME TO exercise_logs_seq;
    END IF;
END $$;
```

### Step 6: Update foreign keys
```sql
-- Drop old foreign key constraints
ALTER TABLE exercise_logs 
DROP CONSTRAINT IF EXISTS fk_exercise_log_exercise;

ALTER TABLE exercise_logs 
DROP CONSTRAINT IF EXISTS fk_exercise_log_user;

-- Add new foreign key constraints with correct names
ALTER TABLE exercise_logs
ADD CONSTRAINT fk_exercise_logs_exercise 
    FOREIGN KEY (exercise_id) REFERENCES exercises(id);

ALTER TABLE exercise_logs
ADD CONSTRAINT fk_exercise_logs_user 
    FOREIGN KEY (user_id) REFERENCES users(id);
```

## Verification

After migration, verify the changes:

```sql
-- List all tables
\dt

-- Should show:
-- users
-- muscle_groups
-- exercises
-- exercise_logs
-- exercise_sets
-- exercise_log_sets

-- Check muscle groups
SELECT * FROM muscle_groups ORDER BY id;

-- Check exercises with muscle groups
SELECT e.id, e.name, mg.name as muscle_group
FROM exercises e
JOIN muscle_groups mg ON e.muscle_group_id = mg.id
ORDER BY e.id
LIMIT 10;

-- Verify foreign keys
SELECT
    tc.table_name, 
    kcu.column_name,
    ccu.table_name AS foreign_table_name,
    ccu.column_name AS foreign_column_name 
FROM information_schema.table_constraints AS tc 
JOIN information_schema.key_column_usage AS kcu
    ON tc.constraint_name = kcu.constraint_name
JOIN information_schema.constraint_column_usage AS ccu
    ON ccu.constraint_name = tc.constraint_name
WHERE tc.constraint_type = 'FOREIGN KEY'
ORDER BY tc.table_name;
```

## Testing

### Test Fresh Installation
```bash
cd exercises-infra/dev
docker-compose down -v
docker-compose up -d

# Wait for initialization
sleep 10

# Check tables
docker-compose exec postgres psql -U postgres -d exercises_dev -c "\dt"

# Check muscle groups
docker-compose exec postgres psql -U postgres -d exercises_dev -c "SELECT * FROM muscle_groups;"

# Check exercises
docker-compose exec postgres psql -U postgres -d exercises_dev -c "SELECT COUNT(*) FROM exercises;"
# Expected: 34

# Check structure
docker-compose exec postgres psql -U postgres -d exercises_dev -c "\d exercises"
# Should show muscle_group_id column
```

## Rollback

If you need to rollback (not recommended):

```sql
-- This would involve reversing all the changes
-- Better to restore from backup

-- Restore from backup
docker exec -i exercises-postgres-dev psql -U postgres -d exercises_dev < backup.sql
```

## Impact Summary

### Database Level
- ✅ Table names now match backend entities exactly
- ✅ Proper relational structure with muscle_groups
- ✅ Better data normalization
- ✅ Cleaner foreign key relationships

### Application Level
- ✅ No backend code changes needed (already correct)
- ✅ SQL scripts now match reality
- ✅ Documentation accurate

### Operations Level
- ✅ Fresh installations work correctly
- ⚠️ Existing deployments need migration
- ✅ Clear migration path provided

## Next Steps

1. ✅ Test fresh installation
2. ✅ Verify seed data loads correctly
3. ✅ Update documentation
4. ⚠️ Plan production migration if needed
5. ✅ Commit changes

---

**Status**: ✅ Complete  
**SQL Scripts**: Aligned with backend  
**Documentation**: Updated  
**Migration Guide**: Provided
